"""
This file was auto-generated by YAPPS. Do not modify!

Tests
>>> from ADTSpec import *
>>> from ADTSpecScanner import parse
>>> stackInt = "Signatures:\\n\\nADT: StackInt\\n\\n    empty   :                  ->  StackInt\\n    push    :  StackInt * int  ->  StackInt\\n    isEmpty :  StackInt        ->  boolean\\n    top     :  StackInt        ->  int\\n    pop     :  StackInt        ->  StackInt\\n    \\nEquations:\\n\\n    (isEmpty (empty)) = #t\\n    (isEmpty (push s k)) = #f\\n\\n    (top (push s k)) = k\\n\\n    (pop (push s k)) = s\\n"
>>> expected = Spec([Signature(('ID', 'StackInt'), [OperationSpec(('ID', 'empty'), [], ('ID', 'StackInt')), OperationSpec(('ID', 'push'), [('ID', 'StackInt'), 'int'], ('ID', 'StackInt')), OperationSpec(('ID', 'isEmpty'), [('ID', 'StackInt')], 'boolean'), OperationSpec(('ID', 'top'), [('ID', 'StackInt')], 'int'), OperationSpec(('ID', 'pop'), [('ID', 'StackInt')], ('ID', 'StackInt'))])], [([('ID', 'isEmpty'), [('ID', 'empty')]], ('boolean', True)), ([('ID', 'isEmpty'), [('ID', 'push'), ('ID', 's'), ('ID', 'k')]], ('boolean', False)), ([('ID', 'top'), [('ID', 'push'), ('ID', 's'), ('ID', 'k')]], ('ID', 'k')), ([('ID', 'pop'), [('ID', 'push'), ('ID', 's'), ('ID', 'k')]], ('ID', 's'))])
>>> parse('input', stackInt) == expected
True
"""
from ADTSpec import *

from string import *
import re
from yappsrt import *

class ADTSpecScannerScanner(Scanner):
    patterns = [
        ('"->"', re.compile('->')),
        ('"\\\\.\\\\.\\\\."', re.compile('\\.\\.\\.')),
        ('";"', re.compile(';')),
        ('"\\\\\\\\x"', re.compile('\\\\x')),
        ('"delete"', re.compile('delete')),
        ('"space"', re.compile('space')),
        ('"esc"', re.compile('esc')),
        ('"return"', re.compile('return')),
        ('"page"', re.compile('page')),
        ('"vtab"', re.compile('vtab')),
        ('"newline"', re.compile('newline')),
        ('"linefeed"', re.compile('linefeed')),
        ('"tab"', re.compile('tab')),
        ('"backspace"', re.compile('backspace')),
        ('"alarm"', re.compile('alarm')),
        ('"nul"', re.compile('nul')),
        ('"x"', re.compile('x')),
        ('"#\\\\\\\\"', re.compile('#\\\\')),
        ('"#[fF]"', re.compile('#[fF]')),
        ('"false"', re.compile('false')),
        ('"#[tT]"', re.compile('#[tT]')),
        ('"true"', re.compile('true')),
        ('"\\\\)"', re.compile('\\)')),
        ('"\\\\("', re.compile('\\(')),
        ('"\\\\s+=\\\\s+"', re.compile('\\s+=\\s+')),
        ('"character"', re.compile('character')),
        ('"string"', re.compile('string')),
        ('"boolean"', re.compile('boolean')),
        ('"int"', re.compile('int')),
        ('"\\\\s+\\\\*\\\\s+"', re.compile('\\s+\\*\\s+')),
        ('"\\\\s+->\\\\s+"', re.compile('\\s+->\\s+')),
        ('"->\\\\s+"', re.compile('->\\s+')),
        ('"\\\\s*:\\\\s+"', re.compile('\\s*:\\s+')),
        ('"\\\\s+"', re.compile('\\s+')),
        ('"ADT:\\\\s+"', re.compile('ADT:\\s+')),
        ('"\\\\s*$"', re.compile('\\s*$')),
        ('"Equations:\\\\s*"', re.compile('Equations:\\s*')),
        ('"\\\\s*Signatures:\\\\s+"', re.compile('\\s*Signatures:\\s+')),
        ('INT', re.compile('[0-9]+')),
        ('STRING', re.compile('"([^\\\\n"]+|\\\\([\\abtnvfrx"]|\\s*\\n\\s*))*"')),
        ('CHARACTER', re.compile('.')),
        ('CONSTITUENT', re.compile('[a-zA-Z\\p{Lu}\\p{Ll}\\p{Lt}\\p{Lm}\\p{Lo}\\p{Mn}\\p{Nl}\\p{No}\\{Pd}\\p{Pc}\\p{Po}\\p{Sc}\\p{Sm}\\p{Sk}\\p{So}\\p{Co}]')),
        ('SPECIALINIT', re.compile('[!$%&*/:<=>?\\^_~]')),
        ('DIGIT', re.compile('[0-9]')),
        ('SUBSEQ', re.compile('[0-9\\p{Nd}\\p{Mc}\\p{Me}+\\-.@]')),
        ('PEC_IDENT', re.compile('[+\\-]')),
        ('HEXDIGIT', re.compile('[0-9a-fA-F]+')),
    ]
    def __init__(self, str):
        Scanner.__init__(self,None,[],str)

class ADTSpecScanner(Parser):
    def input(self):
        self._scan('"\\\\s*Signatures:\\\\s+"')
        signatures = self.signatures()
        self._scan('"Equations:\\\\s*"')
        equations = self.equations()
        self._scan('"\\\\s*$"')
        return Spec(signatures, equations)

    def signatures(self):
        sigs = []
        signature = self.signature()
        sigs.append(signature)
        while self._peek('"ADT:\\\\s+"', '"Equations:\\\\s*"') == '"ADT:\\\\s+"':
            signature = self.signature()
            sigs.append(signature)
        return sigs

    def signature(self):
        self._scan('"ADT:\\\\s+"')
        typename = self.typename()
        self._scan('"\\\\s+"')
        operationSpecs = self.operationSpecs()
        return Signature(typename, operationSpecs)

    def typename(self):
        identifier = self.identifier()
        return identifier

    def operationSpecs(self):
        opSpecs = []
        operationSpec = self.operationSpec()
        self._scan('"\\\\s+"')
        opSpecs.append(operationSpec)
        while self._peek('CONSTITUENT', 'SPECIALINIT', 'PEC_IDENT', '"\\\\.\\\\.\\\\."', '"->"', '"\\\\\\\\x"', '"ADT:\\\\s+"', '"Equations:\\\\s*"') not in ['"ADT:\\\\s+"', '"Equations:\\\\s*"']:
            operationSpec = self.operationSpec()
            self._scan('"\\\\s+"')
            opSpecs.append(operationSpec)
        return opSpecs

    def operationSpec(self):
        operation = self.operation()
        self._scan('"\\\\s*:\\\\s+"')
        _token_ = self._peek('"->\\\\s+"', '"int"', '"boolean"', '"string"', '"character"', 'CONSTITUENT', 'SPECIALINIT', 'PEC_IDENT', '"\\\\.\\\\.\\\\."', '"->"', '"\\\\\\\\x"')
        if _token_ == '"->\\\\s+"':
            self._scan('"->\\\\s+"')
            type = self.type()
            return OperationSpec(operation, [], type)
        else:
            argTypes = self.argTypes()
            self._scan('"\\\\s+->\\\\s+"')
            type = self.type()
            return OperationSpec(operation, argTypes, type)

    def operation(self):
        identifier = self.identifier()
        return identifier

    def argTypes(self):
        types = []
        type = self.type()
        types.append(type)
        while self._peek('"\\\\s+\\\\*\\\\s+"', '"\\\\s+->\\\\s+"') == '"\\\\s+\\\\*\\\\s+"':
            self._scan('"\\\\s+\\\\*\\\\s+"')
            type = self.type()
            types.append(type)
        return types

    def type(self):
        _token_ = self._peek('"int"', '"boolean"', '"string"', '"character"', 'CONSTITUENT', 'SPECIALINIT', 'PEC_IDENT', '"\\\\.\\\\.\\\\."', '"->"', '"\\\\\\\\x"')
        if _token_ == '"int"':
            self._scan('"int"')
            return "int"
        elif _token_ == '"boolean"':
            self._scan('"boolean"')
            return "boolean"
        elif _token_ == '"string"':
            self._scan('"string"')
            return "string"
        elif _token_ == '"character"':
            self._scan('"character"')
            return "character"
        else:
            typename = self.typename()
            return typename

    def equations(self):
        lst = []
        while self._peek('"\\\\s*$"', '"\\\\("', 'INT', '"true"', '"#[tT]"', '"false"', '"#[fF]"', 'STRING', '"#\\\\\\\\"', '"x"', '"nul"', '"alarm"', '"backspace"', '"tab"', '"linefeed"', '"newline"', '"vtab"', '"page"', '"return"', '"esc"', '"space"', '"delete"', 'CONSTITUENT', 'SPECIALINIT', 'PEC_IDENT', '"\\\\.\\\\.\\\\."', '"->"', '"\\\\\\\\x"') != '"\\\\s*$"':
            equation = self.equation()
            self._scan('"\\\\s+"')
            lst.append(equation)
        return lst

    def equation(self):
        expression = self.expression()
        e1 = expression
        self._scan('"\\\\s+=\\\\s+"')
        expression = self.expression()
        return e1, expression

    def expression(self):
        _token_ = self._peek('"\\\\("', 'INT', '"true"', '"#[tT]"', '"false"', '"#[fF]"', 'STRING', '"#\\\\\\\\"', '"x"', '"nul"', '"alarm"', '"backspace"', '"tab"', '"linefeed"', '"newline"', '"vtab"', '"page"', '"return"', '"esc"', '"space"', '"delete"', 'CONSTITUENT', 'SPECIALINIT', 'PEC_IDENT', '"\\\\.\\\\.\\\\."', '"->"', '"\\\\\\\\x"')
        if _token_ != '"\\\\("':
            atom = self.atom()
            return atom
        else:# == '"\\\\("'
            expressions = self.expressions()
            return expressions

    def expressions(self):
        self._scan('"\\\\("')
        operation = self.operation()
        lst = [operation]
        while self._peek('"\\\\s+"', '"\\\\)"') == '"\\\\s+"':
            self._scan('"\\\\s+"')
            expression = self.expression()
            lst.append(expression)
        self._scan('"\\\\)"')
        return lst

    def atom(self):
        _token_ = self._peek('INT', '"true"', '"#[tT]"', '"false"', '"#[fF]"', 'STRING', '"#\\\\\\\\"', '"x"', '"nul"', '"alarm"', '"backspace"', '"tab"', '"linefeed"', '"newline"', '"vtab"', '"page"', '"return"', '"esc"', '"space"', '"delete"', 'CONSTITUENT', 'SPECIALINIT', 'PEC_IDENT', '"\\\\.\\\\.\\\\."', '"->"', '"\\\\\\\\x"')
        if _token_ == 'INT':
            integer = self.integer()
            return 'int', integer
        elif _token_ in ['"true"', '"#[tT]"', '"false"', '"#[fF]"']:
            boolean = self.boolean()
            return 'boolean', boolean
        elif _token_ == 'STRING':
            string = self.string()
            return 'string', string
        elif _token_ not in ['CONSTITUENT', 'SPECIALINIT', 'PEC_IDENT', '"\\\\.\\\\.\\\\."', '"->"', '"\\\\\\\\x"']:
            character = self.character()
            return 'character', character
        else:
            identifier = self.identifier()
            return identifier

    def integer(self):
        INT = self._scan('INT')
        return atoi(INT)

    def boolean(self):
        _token_ = self._peek('"true"', '"#[tT]"', '"false"', '"#[fF]"')
        if _token_ == '"true"':
            self._scan('"true"')
            return True
        elif _token_ == '"#[tT]"':
            self._scan('"#[tT]"')
            return True
        elif _token_ == '"false"':
            self._scan('"false"')
            return False
        else:# == '"#[fF]"'
            self._scan('"#[fF]"')
            return False

    def string(self):
        STRING = self._scan('STRING')
        return eval(STRING)

    def character(self):
        _token_ = self._peek('"#\\\\\\\\"', '"x"', '"nul"', '"alarm"', '"backspace"', '"tab"', '"linefeed"', '"newline"', '"vtab"', '"page"', '"return"', '"esc"', '"space"', '"delete"')
        if _token_ == '"#\\\\\\\\"':
            self._scan('"#\\\\\\\\"')
            CHARACTER = self._scan('CHARACTER')
            return CHARACTER
        elif _token_ != '"x"':
            characterName = self.characterName()
            return characterName
        else:# == '"x"'
            self._scan('"x"')
            HEXDIGIT = self._scan('HEXDIGIT')
            return unichr(int(HEXDIGIT, 16))

    def characterName(self):
        _token_ = self._peek('"nul"', '"alarm"', '"backspace"', '"tab"', '"linefeed"', '"newline"', '"vtab"', '"page"', '"return"', '"esc"', '"space"', '"delete"')
        if _token_ == '"nul"':
            self._scan('"nul"')
            return "nul"
        elif _token_ == '"alarm"':
            self._scan('"alarm"')
            return "alarm"
        elif _token_ == '"backspace"':
            self._scan('"backspace"')
            return "backspace"
        elif _token_ == '"tab"':
            self._scan('"tab"')
            return "tab"
        elif _token_ == '"linefeed"':
            self._scan('"linefeed"')
            return "linefeed"
        elif _token_ == '"newline"':
            self._scan('"newline"')
            return "newline"
        elif _token_ == '"vtab"':
            self._scan('"vtab"')
            return "vtab"
        elif _token_ == '"page"':
            self._scan('"page"')
            return "page"
        elif _token_ == '"return"':
            self._scan('"return"')
            return "return"
        elif _token_ == '"esc"':
            self._scan('"esc"')
            return "esc"
        elif _token_ == '"space"':
            self._scan('"space"')
            return "space"
        else:# == '"delete"'
            self._scan('"delete"')
            return "delete"

    def identifier(self):
        s_identifier = self.s_identifier()
        return 'ID', s_identifier

    def s_identifier(self):
        _token_ = self._peek('CONSTITUENT', 'SPECIALINIT', 'PEC_IDENT', '"\\\\.\\\\.\\\\."', '"->"', '"\\\\\\\\x"')
        if _token_ not in ['PEC_IDENT', '"\\\\.\\\\.\\\\."', '"->"']:
            initial = self.initial()
            result = initial
            while self._peek('CONSTITUENT', 'SPECIALINIT', 'SUBSEQ', '"\\\\\\\\x"', '"\\\\s+"', '"\\\\s*:\\\\s+"', '"\\\\)"', '"\\\\s+\\\\*\\\\s+"', '"\\\\s+=\\\\s+"', '"\\\\s+->\\\\s+"') in ['CONSTITUENT', 'SPECIALINIT', 'SUBSEQ', '"\\\\\\\\x"']:
                subsequent = self.subsequent()
                result += subsequent
            return result
        else:# in ['PEC_IDENT', '"\\\\.\\\\.\\\\."', '"->"']
            peculiar_identifier = self.peculiar_identifier()
            return peculiar_identifier

    def initial(self):
        _token_ = self._peek('CONSTITUENT', 'SPECIALINIT', '"\\\\\\\\x"')
        if _token_ == 'CONSTITUENT':
            CONSTITUENT = self._scan('CONSTITUENT')
            return CONSTITUENT
        elif _token_ == 'SPECIALINIT':
            SPECIALINIT = self._scan('SPECIALINIT')
            return SPECIALINIT
        else:# == '"\\\\\\\\x"'
            inline_hex_escape = self.inline_hex_escape()
            return inline_hex_escape

    def inline_hex_escape(self):
        self._scan('"\\\\\\\\x"')
        HEXDIGIT = self._scan('HEXDIGIT')
        self._scan('";"')
        return unichr(int(HEXDIGIT, 16))

    def subsequent(self):
        _token_ = self._peek('CONSTITUENT', 'SPECIALINIT', 'SUBSEQ', '"\\\\\\\\x"')
        if _token_ != 'SUBSEQ':
            initial = self.initial()
            return initial
        else:# == 'SUBSEQ'
            SUBSEQ = self._scan('SUBSEQ')
            return SUBSEQ

    def peculiar_identifier(self):
        _token_ = self._peek('PEC_IDENT', '"\\\\.\\\\.\\\\."', '"->"')
        if _token_ == 'PEC_IDENT':
            PEC_IDENT = self._scan('PEC_IDENT')
            return PEC_IDENT
        elif _token_ == '"\\\\.\\\\.\\\\."':
            self._scan('"\\\\.\\\\.\\\\."')
            return "..."
        else:# == '"->"'
            self._scan('"->"')
            result = "->"
            while self._peek('CONSTITUENT', 'SPECIALINIT', 'SUBSEQ', '"\\\\\\\\x"', '"\\\\s+"', '"\\\\s*:\\\\s+"', '"\\\\)"', '"\\\\s+\\\\*\\\\s+"', '"\\\\s+=\\\\s+"', '"\\\\s+->\\\\s+"') in ['CONSTITUENT', 'SPECIALINIT', 'SUBSEQ', '"\\\\\\\\x"']:
                subsequent = self.subsequent()
                result += subsequent
            return result


def parse(rule, text):
    P = ADTSpecScanner(ADTSpecScannerScanner(text))
    return wrap_error_reporter(P, rule)



def parseText(rule, text):
    return parse(rule, text + ' ')